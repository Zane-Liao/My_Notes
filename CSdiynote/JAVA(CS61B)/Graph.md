### 1. 图的基本概念
- **图（Graph）**是由节点（顶点）和边组成的结构，通常用来表示各种关系和网络。
- **节点（Node/Vertex）**：图中的一个基本单位，可以代表一个实体或对象。
- **边（Edge）**：连接两个节点的线，表示这两个节点之间的关系或路径。

### 2. 图的种类
- **无向图（Undirected Graph）**：边没有方向，表示连接的节点之间的关系是对称的。
- **有向图（Directed Graph, Digraph）**：边有方向，表示连接的节点之间的关系是单向的。

### 3. 图的表示方法
- **邻接矩阵（Adjacency Matrix）**：使用一个二维数组来表示图，矩阵的行和列对应节点，矩阵中的值表示节点之间是否有边。
- **邻接表（Adjacency List）**：每个节点都有一个列表，列表中存储的是与该节点直接相连的节点。

### 4. 图的基本性质
- **连通性（Connectivity）**：一个图是否可以通过边连接到所有的节点。
- **权重（Weight）**：如果边具有权重，表示从一个节点到另一个节点的代价或距离。
- **路径（Path）**：从一个节点到另一个节点所经过的节点序列。
- **循环（Cycle）**：从某个节点出发经过若干节点又回到该节点的路径。

### 5. 常用算法
- **DFS（深度优先搜索）**和**BFS（广度优先搜索）**：用于遍历图的两种基本方法。
- **最短路径算法**：如Dijkstra算法，用于找到图中两个节点之间的最短路径。

### 6. 应用
图广泛应用于网络、社交关系、交通系统等领域，具有强大的表现力和广泛的应用场景。

这个讲座为后续深入理解和应用图论打下了基础，内容包含了图的基本概念、表示方法、性质以及常用的遍历和搜索算法。

--------

DFS（深度优先搜索）和BFS（广度优先搜索）是图遍历的两种基本算法，它们的核心思想和应用场景各不相同。

### 1. 深度优先搜索（DFS）

**核心思想**：
- 深度优先搜索通过从起始节点出发，一直沿着一条路径走到最深的节点，然后再回溯到最近的分支节点，继续沿另一条路径深入，直到遍历完整个图。

**实现方式**：
- 通常使用**递归**或**栈（Stack）**来实现。
  
**步骤**：
1. 从起始节点开始，访问该节点并将其标记为已访问。
2. 对该节点的所有邻居节点进行迭代，如果邻居节点未被访问，则递归地对其进行深度优先搜索。
3. 回溯到上一个节点，继续对未访问的邻居节点执行相同操作，直到所有节点都被访问。

**特点**：
- **优先深入**：总是尽可能深入到一个节点的最深处。
- **路径发现**：适合用于寻找图中的路径，特别是用于解决迷宫问题、拓扑排序等。

**时间复杂度**：O(V + E)，其中V是图中的节点数，E是图中的边数。

**代码示例（伪代码）**：
```java
void DFS(Node node) {
    if (node == null) return;
    visit(node);
    for (Node neighbor : node.neighbors) {
        if (!neighbor.visited) {
            DFS(neighbor);
        }
    }
}
```

### 2. 广度优先搜索（BFS）

**核心思想**：
- 广度优先搜索通过从起始节点出发，先访问当前节点的所有邻居，然后逐层向外扩展，直到遍历完整个图。

**实现方式**：
- 通常使用**队列（Queue）**来实现。

**步骤**：
1. 从起始节点开始，访问该节点并将其标记为已访问。
2. 将该节点的所有未访问的邻居节点加入队列。
3. 从队列中取出一个节点，访问该节点，并将其所有未访问的邻居节点加入队列。
4. 重复上述过程，直到队列为空，即所有节点都已被访问。

**特点**：
- **优先广度**：优先访问当前节点的所有直接邻居。
- **最短路径**：适合用于寻找图中两个节点之间的最短路径，特别是在无权图中。
  
**时间复杂度**：O(V + E)，其中V是图中的节点数，E是图中的边数。

**代码示例（伪代码）**：
```java
void BFS(Node startNode) {
    Queue<Node> queue = new LinkedList<>();
    queue.add(startNode);
    startNode.visited = true;
    while (!queue.isEmpty()) {
        Node node = queue.poll();
        visit(node);
        for (Node neighbor : node.neighbors) {
            if (!neighbor.visited) {
                queue.add(neighbor);
                neighbor.visited = true;
            }
        }
    }
}
```

### 总结
- **DFS**适合用于问题的深度探索，如路径查找和回溯问题。
- **BFS**更适合寻找最短路径和分层遍历问题。

这两种算法都是图遍历的基础，理解它们有助于深入学习图论中的高级算法和应用。

-----------

[Demo](https://docs.google.com/presentation/d/1lTo8LZUGi3XQ1VlOmBUF9KkJTW_JWsw_DOPq8VBiI3A/edit#slide=id.g76e0dad85_2_380)

深度优先搜索（DFS）的路径查找可以分为几个关键步骤，每个步骤都有具体的操作和逻辑。下面我将详细解释这些步骤：

### 1. **初始化**
- **目标**：准备好DFS所需的数据结构，并设置起始条件。
- **操作**：
  - **起始节点**：选择一个节点作为起点，比如 `s`。
  - **标记数组**：创建一个布尔数组 `marked[]`，用于跟踪每个节点是否已经被访问过。初始时，所有节点都未被访问（`marked[]` 值为 `false`）。
  - **路径数组**：创建一个数组 `edgeTo[]`，用于记录每个节点的上一个节点，即从哪个节点访问到当前节点。初始时，所有 `edgeTo[]` 元素为空。

### 2. **递归访问**
- **目标**：从起始节点出发，逐个访问邻居节点，沿路径深入，直到没有未访问的邻居节点为止。
- **操作**：
  - **访问起始节点**：将起始节点 `s` 标记为已访问，即 `marked[s] = true`。
  - **检查邻居节点**：遍历 `s` 的所有邻居节点 `v`。对于每个邻居 `v`，如果 `v` 未被访问（即 `marked[v] = false`），则：
    - **记录路径**：设置 `edgeTo[v] = s`，表示从 `s` 到 `v` 有一条边。
    - **递归访问**：调用 DFS 继续从 `v` 出发，执行相同的操作，深入探索 `v` 的邻居。

### 3. **回溯**
- **目标**：如果当前节点的所有邻居都已经被访问，或者该节点是一个叶子节点（没有邻居），则回溯到上一个节点，继续探索其他未访问的路径。
- **操作**：
  - 如果从节点 `v` 出发，发现所有邻居节点都已经被访问，则递归函数返回到上一个调用处，即回溯到 `v` 的父节点 `s`，继续检查 `s` 的其他未访问邻居。

### 4. **路径恢复**
- **目标**：一旦目标节点 `t` 被访问，重建从起始节点 `s` 到目标节点 `t` 的路径。
- **操作**：
  - **逆向追踪路径**：从目标节点 `t` 开始，通过 `edgeTo[]` 数组逆向追踪到起始节点 `s`，逐个节点地重建路径。例如，从 `t` 开始，看 `edgeTo[t]` 是什么节点，然后继续追踪到 `edgeTo[edgeTo[t]]`，直到回到 `s`。
  - **路径输出**：构建路径列表或栈，以正确的顺序输出或存储路径。

### 5. **典型伪代码实现**
- DFS 的基本伪代码如下所示，展示了如何实现上述步骤：
```java
void dfs(Vertex v) {
    marked[v] = true; // 标记 v 为已访问
    for (Vertex w : v.neighbors) { // 遍历 v 的所有邻居节点
        if (!marked[w]) { // 如果邻居 w 未被访问
            edgeTo[w] = v; // 记录路径，即从 v 到 w
            dfs(w); // 递归访问 w
        }
    }
}
```
- 当目标节点 `t` 被访问时，通过 `edgeTo[]` 可以恢复完整路径：
```java
Stack<Vertex> path = new Stack<>();
for (Vertex x = t; x != s; x = edgeTo[x]) {
    path.push(x);
}
path.push(s);
```

### 6. **DFS 的特点与应用**
- **特点**：
  - **深度优先**：DFS 一直沿着一条路径深入探索，直到无法再深入为止。
  - **回溯机制**：通过回溯，可以探索所有可能的路径，确保整个图被遍历。
  
- **应用场景**：
  - **路径查找**：寻找从起点到终点的所有可能路径。
  - **拓扑排序**：在有向无环图（DAG）中确定节点的线性顺序。
  - **连通分量**：在无向图中找到所有的连通分量，即图中所有相互连通的子图。

通过详细理解这些步骤，DFS 可以灵活地应用于各种复杂的图问题中。