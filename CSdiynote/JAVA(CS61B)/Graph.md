### 1. 图的基本概念
- **图（Graph）**是由节点（顶点）和边组成的结构，通常用来表示各种关系和网络。
- **节点（Node/Vertex）**：图中的一个基本单位，可以代表一个实体或对象。
- **边（Edge）**：连接两个节点的线，表示这两个节点之间的关系或路径。

### 2. 图的种类
- **无向图（Undirected Graph）**：边没有方向，表示连接的节点之间的关系是对称的。
- **有向图（Directed Graph, Digraph）**：边有方向，表示连接的节点之间的关系是单向的。

### 3. 图的表示方法
- **邻接矩阵（Adjacency Matrix）**：使用一个二维数组来表示图，矩阵的行和列对应节点，矩阵中的值表示节点之间是否有边。
- **邻接表（Adjacency List）**：每个节点都有一个列表，列表中存储的是与该节点直接相连的节点。

### 4. 图的基本性质
- **连通性（Connectivity）**：一个图是否可以通过边连接到所有的节点。
- **权重（Weight）**：如果边具有权重，表示从一个节点到另一个节点的代价或距离。
- **路径（Path）**：从一个节点到另一个节点所经过的节点序列。
- **循环（Cycle）**：从某个节点出发经过若干节点又回到该节点的路径。

### 5. 常用算法
- **DFS（深度优先搜索）**和**BFS（广度优先搜索）**：用于遍历图的两种基本方法。
- **最短路径算法**：如Dijkstra算法，用于找到图中两个节点之间的最短路径。

### 6. 应用
图广泛应用于网络、社交关系、交通系统等领域，具有强大的表现力和广泛的应用场景。

这个讲座为后续深入理解和应用图论打下了基础，内容包含了图的基本概念、表示方法、性质以及常用的遍历和搜索算法。

-----------

[Demo](https://docs.google.com/presentation/d/1lTo8LZUGi3XQ1VlOmBUF9KkJTW_JWsw_DOPq8VBiI3A/edit#slide=id.g76e0dad85_2_380)

深度优先搜索（DFS）的路径查找可以分为几个关键步骤，每个步骤都有具体的操作和逻辑。下面我将详细解释这些步骤：

### 1. **初始化**
- **目标**：准备好DFS所需的数据结构，并设置起始条件。
- **操作**：
  - **起始节点**：选择一个节点作为起点，比如 `s`。
  - **标记数组**：创建一个布尔数组 `marked[]`，用于跟踪每个节点是否已经被访问过。初始时，所有节点都未被访问（`marked[]` 值为 `false`）。
  - **路径数组**：创建一个数组 `edgeTo[]`，用于记录每个节点的上一个节点，即从哪个节点访问到当前节点。初始时，所有 `edgeTo[]` 元素为空。

### 2. **递归访问**
- **目标**：从起始节点出发，逐个访问邻居节点，沿路径深入，直到没有未访问的邻居节点为止。
- **操作**：
  - **访问起始节点**：将起始节点 `s` 标记为已访问，即 `marked[s] = true`。
  - **检查邻居节点**：遍历 `s` 的所有邻居节点 `v`。对于每个邻居 `v`，如果 `v` 未被访问（即 `marked[v] = false`），则：
    - **记录路径**：设置 `edgeTo[v] = s`，表示从 `s` 到 `v` 有一条边。
    - **递归访问**：调用 DFS 继续从 `v` 出发，执行相同的操作，深入探索 `v` 的邻居。

### 3. **回溯**
- **目标**：如果当前节点的所有邻居都已经被访问，或者该节点是一个叶子节点（没有邻居），则回溯到上一个节点，继续探索其他未访问的路径。
- **操作**：
  - 如果从节点 `v` 出发，发现所有邻居节点都已经被访问，则递归函数返回到上一个调用处，即回溯到 `v` 的父节点 `s`，继续检查 `s` 的其他未访问邻居。

### 4. **路径恢复**
- **目标**：一旦目标节点 `t` 被访问，重建从起始节点 `s` 到目标节点 `t` 的路径。
- **操作**：
  - **逆向追踪路径**：从目标节点 `t` 开始，通过 `edgeTo[]` 数组逆向追踪到起始节点 `s`，逐个节点地重建路径。例如，从 `t` 开始，看 `edgeTo[t]` 是什么节点，然后继续追踪到 `edgeTo[edgeTo[t]]`，直到回到 `s`。
  - **路径输出**：构建路径列表或栈，以正确的顺序输出或存储路径。

### 5. **典型伪代码实现**
- DFS 的基本伪代码如下所示，展示了如何实现上述步骤：
```java
void dfs(Vertex v) {
    marked[v] = true; // 标记 v 为已访问
    for (Vertex w : v.neighbors) { // 遍历 v 的所有邻居节点
        if (!marked[w]) { // 如果邻居 w 未被访问
            edgeTo[w] = v; // 记录路径，即从 v 到 w
            dfs(w); // 递归访问 w
        }
    }
}
```
- 当目标节点 `t` 被访问时，通过 `edgeTo[]` 可以恢复完整路径：
```java
Stack<Vertex> path = new Stack<>();
for (Vertex x = t; x != s; x = edgeTo[x]) {
    path.push(x);
}
path.push(s);
```

### 6. **DFS 的特点与应用**
- **特点**：
  - **深度优先**：DFS 一直沿着一条路径深入探索，直到无法再深入为止。
  - **回溯机制**：通过回溯，可以探索所有可能的路径，确保整个图被遍历。
  
- **应用场景**：
  - **路径查找**：寻找从起点到终点的所有可能路径。
  - **拓扑排序**：在有向无环图（DAG）中确定节点的线性顺序。
  - **连通分量**：在无向图中找到所有的连通分量，即图中所有相互连通的子图。

通过详细理解这些步骤，DFS 可以灵活地应用于各种复杂的图问题中。

-------

DFS 是一种用于遍历或搜索图或树的数据结构的算法，与广度优先搜索（BFS）不同，DFS 更深入地探索图的每个分支。

### 伪代码解释

```plaintext
Initialize the fringe, an empty stack
push the starting vertex on the fringe
while fringe is not empty:
    pop a vertex off the fringe
    if vertex is not marked:
        mark the vertex
        visit vertex
        for each neighbor of vertex:
            if neighbor not marked:
                push neighbor to fringe
```

### 具体步骤解析

1. **初始化边缘（fringe）**：
   - 边缘（fringe）在这里是一个栈（stack），用于存储需要被访问的顶点。栈具有后进先出（LIFO）的特性，这非常适合深度优先搜索。

2. **将起始顶点压入栈中**：
   - 从一个起始顶点开始，将其压入栈中，准备开始搜索。

3. **当栈不为空时，循环执行以下操作**：
   - 只要栈中有顶点，继续执行循环。

4. **从栈中弹出一个顶点 `v`**：
   - 每次从栈的顶端弹出一个顶点 `v`，并处理它。

5. **如果顶点 `v` 未被标记**：
   - 检查顶点 `v` 是否已经被访问过。如果未被访问，则标记它。

6. **标记顶点 `v` 并访问它**：
   - 标记顶点 `v` 为已访问，以防止重复处理。然后可以在这个步骤中执行访问操作，例如打印顶点或执行其他相关操作。

7. **遍历顶点 `v` 的每个邻居**：
   - 对于顶点 `v` 的每个邻居，检查是否已经访问过。

8. **如果邻居未被标记**：
   - 如果邻居未被标记（即未访问过），则将其压入栈中，等待进一步处理。

### DFS 的特点

- **深度优先**: DFS 会沿着图的一个分支一直深入，直到无法继续为止，然后回溯到上一个分支点继续探索。
- **使用栈实现**: DFS 使用栈来实现搜索过程。在大多数编程语言中，递归调用可以隐式地使用函数调用栈来实现 DFS。
- **适用于找出连通分量**: DFS 可以用来找出图中的连通分量，即所有与起始顶点相连的顶点集合。

### 图示理解

假设有一个简单的无向图，起始顶点是 `A`，图结构如下：

```
A -- B -- C
|    |
D -- E
```

使用 DFS，遍历顺序可能是 `A -> B -> E -> D -> C`。在这个过程中，DFS 会先从 `A` 出发，沿着 `B -> E` 继续深入，然后回溯到 `B` 继续探索 `D`，最后探索 `C`。

### 总结

DFS 是一种通过深入搜索图的每一个分支来进行遍历的算法。与 BFS 不同，它适合处理需要遍历所有可能路径的场景，例如找出图中的所有路径、检测图中的环等。使用栈的特性使得 DFS 能够有效地管理搜索路径。

---------
[demo](https://docs.google.com/presentation/d/1JoYCelH4YE6IkSMq_LfTJMzJ00WxDj7rEa49gYmAtc4/edit#slide=id.g76e0dad85_2_380)

BFS（广度优先搜索）是一种用于遍历或搜索图的算法。它的基本思想是从起始顶点开始，逐层遍历图中的节点，先访问距离起始顶点较近的节点，再访问较远的节点。

### 伪代码解释

```plaintext
Initialize the fringe, an empty queue 
add the starting vertex to the fringe
mark the starting vertex
while fringe is not empty:
    remove vertex v from the fringe
    for each neighbor n of vertex v:
        if n is not marked:
            add n to fringe
            mark n
            set edgeTo[n] = v
            set distTo[n] = distTo[v] + 1
```

### 具体步骤解析

1. **初始化边缘（fringe）**：
   - 边缘（fringe）在这里是一个队列（queue），用于存储需要被访问的顶点。队列具有先进先出（FIFO）的特性，这非常适合广度优先搜索。

2. **将起始顶点加入队列**：
   - 我们从一个起始顶点开始（可以是图中的任意一个顶点），将其加入队列，并标记它为已访问。

3. **标记起始顶点**：
   - 将起始顶点标记为已访问，以防止重复处理。

4. **当队列不为空时，循环执行以下操作**：
   - 只要队列中有顶点，继续执行循环。

5. **从队列中移除一个顶点 `v`**：
   - 每次从队列的前端取出一个顶点 `v`，然后处理它。

6. **遍历顶点 `v` 的每个邻居 `n`**：
   - 对于顶点 `v` 的每个邻居 `n`，检查是否已经访问过。

7. **如果邻居 `n` 未被标记**：
   - 如果 `n` 没有被标记（即未访问过），执行以下步骤：
     - 将 `n` 加入队列，等待进一步处理。
     - 标记 `n` 为已访问。
     - **`edgeTo[n] = v`**：这一步表示记录从顶点 `v` 到顶点 `n` 的路径，这样以后可以追踪路径。
     - **`distTo[n] = distTo[v] + 1`**：这一步表示计算顶点 `n` 距离起始顶点的距离，即 `v` 的距离加上 1。

### BFS 的应用

- **寻找最短路径**: 在无权图中，BFS 可以用于寻找从起始顶点到所有其他顶点的最短路径，因为它按层次遍历，保证了最短路径的计算。
- **图的遍历**: BFS 可以完整遍历图中所有的节点，适用于寻找连通分量、检测环等。

### 图示理解

假设有一个简单的无向图，起始顶点是 `A`，图结构如下：

```
A -- B -- C
|    |
D -- E
```

使用 BFS，遍历顺序将会是 `A -> B -> D -> C -> E`，并且每个节点的 `distTo` 会记录到 `A` 的最短路径，`edgeTo` 记录每个节点到达时的前一个节点。例如，`edgeTo[C]` 是 `B`，`distTo[C]` 是 `2`。
```java
public class Graph {
  public Graph(int V):               // Create empty graph with v vertices
  public void addEdge(int v, int w): // add an edge v-w
  Iterable<Integer> adj(int v):      // vertices adjacent to v
  int V():                           // number of vertices
  int E():                           // number of edges
```
- **构造函数 (`Graph(int V)`)**: 初始化一个有 `V` 个顶点但没有边的图。邻接表 `adj` 使用一个数组，其中每个元素是一个 `ArrayList`，存储与某个顶点相邻的所有顶点。

- **`addEdge(int v, int w)`**: 该方法向图中添加一条边 `v-w`，即将顶点 `w` 添加到 `v` 的邻接表中，并将顶点 `v` 添加到 `w` 的邻接表中。由于这是无向图，所以需要将 `v` 和 `w` 互相添加。

- **`adj(int v)`**: 返回与顶点 `v` 相邻的所有顶点。这个方法返回一个 `Iterable<Integer>`，因此可以使用增强的 `for` 循环来遍历相邻的顶点。

- **`V()`**: 返回图中的顶点数。

- **`E()`**: 返回图中的边数。