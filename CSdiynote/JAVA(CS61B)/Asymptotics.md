以下是按速度从快到慢以及输入大小 \(n\) 变化情况整理的时间复杂度表格：

### 时间复杂度速度表

| 时间复杂度           | 描述                        | 示例               |
| --------------- | ------------------------- | ---------------- |
| \(O(1)\)        | 常数时间复杂度：与输入数据大小无关         | 数组访问，哈希表查找       |
| \(O(\log n)\)   | 对数时间复杂度：输入数据大小的对数关系       | 二分查找，平衡二叉搜索树操作   |
| \(O(n)\)        | 线性时间复杂度：与输入数据大小成正比        | 线性搜索，遍历数组        |
| \(O(n \log n)\) | 线性对数时间复杂度：与输入数据大小的对数乘积成正比 | 快速排序，归并排序，堆排序    |
| \(O(n^2)\)      | 平方时间复杂度：与输入数据大小的平方成正比     | 冒泡排序，插入排序，选择排序   |
| \(O(n^3)\)      | 立方时间复杂度：与输入数据大小的立方成正比     | Floyd-Warshall算法 |
| \(O(2^n)\)      | 指数时间复杂度：随输入数据大小呈指数增长      | 子集和问题的暴力算法，旅行商问题 |
| \(O(n!)\)       | 阶乘时间复杂度：随输入数据大小呈阶乘增长      | 旅行商问题的暴力算法，排列生成  |

### 时间复杂度与输入大小 \(n\) 的关系

| 时间复杂度           | \(n = 10\) | \(n = 100\)             | \(n = 1000\)             | \(n = 10000\) |
| --------------- | ---------- | ----------------------- | ------------------------ | ------------- |
| \(O(1)\)        | 1          | 1                       | 1                        | 1             |
| \(O(\log n)\)   | 3          | 7                       | 10                       | 13            |
| \(O(n)\)        | 10         | 100                     | 1000                     | 10000         |
| \(O(n \log n)\) | 30         | 700                     | 10000                    | 130000        |
| \(O(n^2)\)      | 100        | 10000                   | 1000000                  | 100000000     |
| \(O(n^3)\)      | 1000       | 1000000                 | 1000000000               | 1000000000000 |
| \(O(2^n)\)      | 1024       | \(1.27 \times 10^{30}\) | \(1.07 \times 10^{301}\) | \(10^{3010}\) |
| \(O(n!)\)       | 3.6M       | 超大值                     | 超大值                      | 超大值           |

注：
- 表中的对数均以2为底。
- \(O(2^n)\) 和 \(O(n!)\) 的值随着 \(n\) 的增长非常快，即使对于较小的 \(n\) 也会变得极其庞大。

### 总结

通过这张表格，可以清楚地看到不同时间复杂度的增长速度。理解这些增长模式有助于选择合适的算法以处理不同规模的数据。如果有更多问题或需要进一步的解释，请告诉我！