动态规划（Dynamic Programming，简称DP）是一种算法设计方法，用于解决具有**重叠子问题**和**最优子结构**性质的问题。其基本思想是将问题分解为更小的子问题，通过将这些子问题的解存储起来，避免重复计算，从而提高效率。

### 动态规划的核心思想
1. **重叠子问题（Overlapping Subproblems）**：问题可以被分解为相互重叠的子问题。这意味着相同的子问题会被多次计算。动态规划通过记录子问题的解来避免重复计算。

2. **最优子结构（Optimal Substructure）**：问题的最优解可以通过其子问题的最优解构建出来。也就是说，问题的全局最优解依赖于子问题的局部最优解。

### 动态规划的步骤
1. **定义状态**：选择适当的状态表示问题的不同阶段。通常，状态由一些变量来表示，这些变量能够唯一确定一个子问题。

2. **状态转移方程**：找出不同状态之间的关系，建立状态转移方程。这个方程描述了如何通过子问题的解来构建当前问题的解。

3. **初始条件**：确定初始状态的值，也就是最小的子问题的解。

4. **计算顺序**：确定计算子问题的顺序，通常是从最小的子问题开始，逐步计算出更大的子问题的解。

5. **返回结果**：根据问题的要求，返回所需的最终结果。

### 动态规划的例子
一个经典的动态规划问题是**斐波那契数列**的计算。

斐波那契数列的定义是：
- F(0) = 0
- F(1) = 1
- F(n) = F(n-1) + F(n-2) for n ≥ 2

通过动态规划，我们可以存储之前计算的F(n-1)和F(n-2)的值，从而避免重复计算，提高效率。

### 动态规划的常见应用
- **最短路径问题**（如Dijkstra算法、Floyd-Warshall算法）
- **背包问题**
- **最长公共子序列问题**
- **矩阵链乘法问题**
- **编辑距离问题**

动态规划在很多复杂问题中都有广泛的应用，是一种非常重要的算法设计思想。

--------

**LIS (Longest Increasing Subsequence)** 和 **LLIS (Longest Lexicographically Increasing Subsequence)** 都是常见的序列问题，在计算机科学中有广泛的应用。下面是它们的详细解释。

### Longest Increasing Subsequence (LIS)
**LIS** 是指在一个序列中找到最长的子序列，这个子序列中的元素是严格递增的。这个子序列不一定是连续的。

#### 示例
假设你有一个序列：`[10, 9, 2, 5, 3, 7, 101, 18]`，其LIS是`[2, 3, 7, 101]`，长度为4。

#### 动态规划求解方法
使用动态规划可以有效地求解LIS问题。其基本思想如下：

1. **状态定义**：
   设 `dp[i]` 表示以元素 `arr[i]` 结尾的最长递增子序列的长度。

2. **状态转移方程**：
   对于每个 `j` (j < i)，如果 `arr[j] < arr[i]`，则可以扩展 `dp[j]`，即 `dp[i] = max(dp[i], dp[j] + 1)`。

3. **初始化**：
   每个 `dp[i]` 初始值为1，因为最小的递增子序列长度至少为1（就是它自身）。

4. **最终结果**：
   LIS 的长度就是 `dp` 数组中的最大值。

```plaintext
function LIS(arr):
    n = length of arr
    dp = [1] * n
    
    for i in range(1, n):
        for j in range(0, i):
            if arr[j] < arr[i]:
                dp[i] = max(dp[i], dp[j] + 1)
    
    return max(dp)
```

### Longest Lexicographically Increasing Subsequence (LLIS)
**LLIS** 是指在一个序列中找到最长的子序列，这个子序列不仅是严格递增的，而且还在字典序上具有最小的顺序。

#### 示例
考虑序列`[1, 2, 5, 3, 4]`。其中的LIS是`[1, 2, 3, 4]`，而LLIS也是`[1, 2, 3, 4]`。

但是如果序列是`[3, 2, 1, 2, 3]`，其中的LIS是`[1, 2, 3]`，而LLIS是`[2, 3]`，因为在字典序上`[2, 3]`比`[1, 2, 3]`要小。

#### 动态规划求解方法
求解LLIS的方式与LIS相似，但在比较时要考虑字典序。

1. **状态定义**：
   设 `dp[i]` 表示以元素 `arr[i]` 结尾的最长字典序递增子序列的长度。

2. **状态转移方程**：
   对于每个 `j` (j < i)，如果 `arr[j] < arr[i]`，且 `arr[i]` 在字典序上优于当前的子序列，则更新 `dp[i]`。

3. **初始化**：
   和LIS一样，每个 `dp[i]` 初始值为1。

4. **最终结果**：
   LLIS 的长度就是 `dp` 数组中的最大值。

### 总结
- **LIS** 只考虑序列中的数字大小关系，找到最长的递增子序列。
- **LLIS** 不仅要求序列递增，还要求序列在字典序上是最小的。

LIS和LLIS都可以通过动态规划来求解，不过LLIS涉及到字典序的比较，可能需要更复杂的判断条件。

------

DAGSPT（DAG Shortest Path Tree）算法的工作原理。

### 示例DAG

假设我们有以下DAG：

```
A --> B --> C
 \         /
  \       /
   --> D 
```

其中：
- A → B 权重为 1
- A → D 权重为 2
- B → C 权重为 3
- D → C 权重为 1

### 步骤 1：图的拓扑排序
为了应用DAGSPT算法，首先需要对图进行拓扑排序。拓扑排序是一种线性排序，使得每条有向边的起点在排序中出现在终点之前。

对于这个图，可能的拓扑排序之一是：`A -> B -> D -> C`。

### 步骤 2：初始化 `distTo`
初始化一个 `distTo` 数组，用来记录从源顶点出发到每个顶点的最短路径距离。假设我们从顶点 `A` 出发：

- `distTo[A] = 0`（从 `A` 到 `A` 的距离为 0）
- 对于其他顶点，初始设置为无穷大：`distTo[B] = ∞`，`distTo[D] = ∞`，`distTo[C] = ∞`

### 步骤 3：按照拓扑排序更新最短路径
按照拓扑排序顺序处理每个顶点，更新其相邻顶点的最短路径值。

1. **处理顶点 A**：
   - 从 A 到 B：`distTo[B] = min(distTo[B], distTo[A] + weight(A, B)) = min(∞, 0 + 1) = 1`
   - 从 A 到 D：`distTo[D] = min(distTo[D], distTo[A] + weight(A, D)) = min(∞, 0 + 2) = 2`

   更新后：`distTo = {A: 0, B: 1, D: 2, C: ∞}`

2. **处理顶点 B**：
   - 从 B 到 C：`distTo[C] = min(distTo[C], distTo[B] + weight(B, C)) = min(∞, 1 + 3) = 4`

   更新后：`distTo = {A: 0, B: 1, D: 2, C: 4}`

3. **处理顶点 D**：
   - 从 D 到 C：`distTo[C] = min(distTo[C], distTo[D] + weight(D, C)) = min(4, 2 + 1) = 3`

   更新后：`distTo = {A: 0, B: 1, D: 2, C: 3}`

4. **处理顶点 C**：
   - 顶点 C 没有出边，所以 `distTo` 不变。

### 步骤 4：最终结果
`distTo` 数组最终表示从源顶点 A 到所有其他顶点的最短路径：

- 从 A 到 A 的最短路径为 0
- 从 A 到 B 的最短路径为 1
- 从 A 到 D 的最短路径为 2
- 从 A 到 C 的最短路径为 3

### 长路径问题的转化
如果我们想求DAG中的最长路径，可以按照前面所说的方法，把每条边的权重设置为负数。这样，当我们使用DAGSPT算法时，它会自动寻找最长路径。

假设我们将所有边的权重乘以 -1：

- A → B 权重变为 -1
- A → D 权重变为 -2
- B → C 权重变为 -3
- D → C 权重变为 -1

重新应用DAGSPT算法后，`distTo`的结果会代表负权重下的最短路径（即原图的最长路径）。通过取这些值的绝对值，我们可以得到最长路径的长度。

### 总结
通过这个实例，你可以看到DAGSPT算法如何在有向无环图中通过拓扑排序来高效地计算最短路径。并且通过将边权重转化为负数，还可以用于计算最长路径。这个方法特别适用于DAG，因为没有负环的担忧，算法可以在拓扑顺序下逐顶点处理，实现高效的路径计算。