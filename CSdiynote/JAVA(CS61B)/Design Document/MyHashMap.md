此小型文档旨在写lab8: HashMap。作为一份设计文档，它包含了实现原理和实现方法，还有将其他数据结构与此实现结构作为比较（运行时间）。


get()查找 `HashMap` 通过key的hashcode()找到对应的index，然后遍历该位置的链表或树，找到匹配的key并返回对应的value。
put()插入 `HashMap` 通过key的hashcode()找到对应的index，然后查看该index是否已经有元素。如果没有，直接插入；如果有碰撞，会将新的键值对插入到对应链表或树中。
keySet() 这里的 `keySet()` 方法声明是用于返回一个包含当前 `HashMap` 所有键的 `Set` 视图。你可能需要实现它而不是直接返回 `null`

--------

其目的是构建一个自定义的哈希表类，类似于 Java 内置的 `HashMap`，并通过特定规则优化性能和空间使用。

### 总结要点：

1. **构造函数**：
    
    - `MyHashMap()`：无参构造，使用默认初始大小（`16`）和负载因子（`0.75`）。
    - `MyHashMap(int initialSize)`：指定初始桶数的构造函数，负载因子仍为默认值。
    - `MyHashMap(int initialSize, double loadFactor)`：同时指定初始桶数和负载因子。
2. **负载因子**：
    
    - 当负载因子（`loadFactor = N/M`，即元素数量与桶数量的比值）超过指定值时，需要扩容。扩容时应成倍增加哈希表大小，而不是线性增长。
3. **冲突处理**：
    
    - 使用**单独链表法（Separate Chaining）**处理冲突，允许多个元素存储在同一个桶中，通过链表或类似数据结构（如 `ArrayList` 或 `HashSet`）来处理哈希碰撞。
4. **存储桶类型**：
    
    - 必须使用 `ArrayList`、`LinkedList` 或 `HashSet` 来存储桶中的元素，并且只能使用 `Collection` 接口中的方法（如 `add`、`remove` 和 `iterator`）。
5. **恒定摊销时间**：
    
    - 所有操作应当是恒定的摊销时间，假设 `hashCode` 能均匀分布。
    - 注意：`hashCode` 可以返回负值，代码应当处理这个问题。
6. **键的重复处理**：
    
    - 如果插入了重复的键，`MyHashMap` 应该更新该键对应的值。

### 设计的目的：

- **效率**：通过适当的负载因子控制和指数扩容机制，确保哈希表在使用过程中保持高效，避免过多冲突影响查找速度。
- **灵活性**：支持自定义初始桶数和负载因子，用户可以根据需求调整 `MyHashMap` 的空间和时间性能。
- **正确性**：通过冲突处理、键值更新和扩容机制，确保哈希表在各种操作下能正确存储和更新数据。

---------

HashMap Representation with Key-Value Pairs:

+----------------------+     +--------------------------+     +--------------------------+
|      Bucket 0        | --> |       Node               | --> |       Node               |
|                      |     |   [key1, value1]         |     |   [key5, value5]         |
|                      |     +--------------------------+     +--------------------------+
|                      |
+----------------------+
|      Bucket 1        | --> null
+----------------------+
|      Bucket 2        | --> |       Node               | --> null
|                      |     |   [key2, value2]         |
+----------------------+     +--------------------------+
|      Bucket 3        | --> null
+----------------------+
|      Bucket 4        | --> |       Node               | --> |       Node               |
|                      |     |   [key3, value3]         |     |   [key6, value6]         |
|                      |     +--------------------------+     +--------------------------+
+----------------------+
|      Bucket 5        | --> |       Node               | --> null
|                      |     |   [key4, value4]         |
+----------------------+     +--------------------------+


/**
* 返回一个要放置在哈希表存储桶中的新节点
*/

/**
* 返回一个要作为哈希表存储桶的数据结构
*
* 哈希表存储桶的唯一要求是我们可以：
* 1. 插入项目（“add”方法）
* 2. 删除项目（“remove”方法）
* 3. 遍历项目（“iterator”方法）
*
* java.util.Collection 支持这些方法中的每一种方法，
* Java 中的大多数数据结构都继承自 Collection，因此我们
* 可以使用几乎任何数据结构作为存储桶。
*
* 重写此方法以使用不同的数据结构作为
* 底层存储桶类型
*
* 请务必调用此工厂方法，而不是使用 NEW 运算符创建您自己的存储桶数据结构！
*/

/**
* 返回一个表来支持我们的哈希表。根据上面的注释
*，此表可以是 Collection 对象的数组
*
* 创建表时务必调用此工厂方法，以便
* 所有 BUCKET 类型均为 JAVA.UTIL.COLLECTION
*
* @param tableSize 要创建的表的大小
*/